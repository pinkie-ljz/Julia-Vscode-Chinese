<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>测试项框架 · VS Code中的Julia插件</title><meta name="title" content="测试项框架 · VS Code中的Julia插件"/><meta property="og:title" content="测试项框架 · VS Code中的Julia插件"/><meta property="twitter:title" content="测试项框架 · VS Code中的Julia插件"/><meta name="description" content="Documentation for VS Code中的Julia插件."/><meta property="og:description" content="Documentation for VS Code中的Julia插件."/><meta property="twitter:description" content="Documentation for VS Code中的Julia插件."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">VS Code中的Julia插件</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../index.html">主页</a></li><li><a class="tocitem" href="../gettingstarted.html">入门指南</a></li><li><a class="tocitem" href="../faq.html">常见问题</a></li><li><span class="tocitem">用户指南</span><ul><li><a class="tocitem" href="runningcode.html">代码运行</a></li><li><a class="tocitem" href="keybindings.html">快捷键与命名</a></li><li><a class="tocitem" href="env.html">Julia环节</a></li><li><a class="tocitem" href="codenavigation.html">代码导航</a></li><li><a class="tocitem" href="editingcode.html">代码编辑</a></li><li><a class="tocitem" href="formatter.html">代码格式化</a></li><li><a class="tocitem" href="plotgallery.html">绘图</a></li><li><a class="tocitem" href="grid.html">表格查看</a></li><li><a class="tocitem" href="linter.html">代码检查器</a></li><li><a class="tocitem" href="profiler.html">代码分析</a></li><li><a class="tocitem" href="debugging.html">调试</a></li><li><a class="tocitem" href="weave.html">Julia的Markdown文档</a></li><li><a class="tocitem" href="remote.html">远程</a></li><li class="is-active"><a class="tocitem" href="testitems.html">测试项框架</a><ul class="internal"><li><a class="tocitem" href="#编写测试项"><span>编写测试项</span></a></li><li><a class="tocitem" href="#在-VS-Code-中运行测试项"><span>在 VS Code 中运行测试项</span></a></li><li><a class="tocitem" href="#从命令行运行测试"><span>从命令行运行测试</span></a></li><li><a class="tocitem" href="#标签"><span>标签</span></a></li><li><a class="tocitem" href="#在-VS-Code-中并行执行测试"><span>在 VS Code 中并行执行测试</span></a></li><li><a class="tocitem" href="#管理测试进程"><span>管理测试进程</span></a></li><li><a class="tocitem" href="#TestItemRunner.jl-中的过滤支持"><span>TestItemRunner.jl 中的过滤支持</span></a></li><li><a class="tocitem" href="#默认导入选项"><span>默认导入选项</span></a></li><li><a class="tocitem" href="#在-@testitem-之间共享代码"><span>在 <code>@testitem</code> 之间共享代码</span></a></li><li><a class="tocitem" href="#@testitem-的调试"><span><code>@testitem</code> 的调试</span></a></li><li><a class="tocitem" href="#代码覆盖率"><span>代码覆盖率</span></a></li></ul></li></ul></li><li><span class="tocitem">发展者文档</span><ul><li><a class="tocitem" href="../devdocs/devdocs.html">概况</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">用户指南</a></li><li class="is-active"><a href="testitems.html">测试项框架</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="testitems.html">测试项框架</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="测试项框架"><a class="docs-heading-anchor" href="#测试项框架">测试项框架</a><a id="测试项框架-1"></a><a class="docs-heading-anchor-permalink" href="#测试项框架" title="Permalink"></a></h1><p>测试项框架(test item framework)是一组软件包和用户界面功能，使编写和运行 Julia 软件包的测试变得简单。</p><p>该框架的主要好处在于，测试代码可以结构化为测试项，从而可以单独轻松运行这些测试项。</p><p>Julia VS Code 扩展对测试项框架提供了广泛支持，但测试项框架本身可以完全独立于 VS Code 使用。用户可以编写测试项并通过命令行界面（或标准的 <code>Pkg.test</code> 功能）运行它们，而无需使用 VS Code。</p><h2 id="编写测试项"><a class="docs-heading-anchor" href="#编写测试项">编写测试项</a><a id="编写测试项-1"></a><a class="docs-heading-anchor-permalink" href="#编写测试项" title="Permalink"></a></h2><p>测试项框架的核心功能是可以将测试结构化为 <code>@testitem</code> 块，然后单独运行这些测试，而无需一次性运行所有测试。一个典型的 <code>@testitem</code> 可能如下所示：</p><pre><code class="language-julia hljs">@testitem &quot;First tests&quot; begin
    x = foo(&quot;bar&quot;)

    @test length(x)==3
    @test x == &quot;bar&quot;
end</code></pre><p>一个 <code>@testitem</code> 总是有一个名称（此处为 &quot;First tests&quot;），然后是一个 <code>begin ... end</code> 块中的代码。<code>@testitem</code> 内部的代码必须能够独立执行，即不能依赖于 <code>@testitem</code> 外部的代码，除非该代码以某种方式被显式导入或包含在 <code>@testitem</code> 内部。有一个例外：<code>@testitem</code> 内的代码将在一个临时模块内运行，其中已经执行了 <code>using Test</code> 和 <code>using MYPACKAGENAME</code>，因此可以直接使用从 <code>Test</code> 模块或正在开发的软件包中导出的任何内容。在上面的例子中，这适用于 <code>foo</code> 函数（假设在被测试的软件包中定义）和 <code>@test</code> 宏。</p><p><code>@testitem</code> 可以在包中的任何地方出现。它们不必位于 <code>test</code> 文件夹中，也不必在 <code>test/runtests.jl</code> 包含的文件中。事实上，<code>@testitem</code> 甚至可以位于常规包代码内部，例如与正在测试的代码相邻。在这种情况下，您只需依赖于 <a href="https://github.com/julia-vscode/TestItems.jl">TestItems.jl</a> 包，以便访问 <code>@testitem</code> 宏。如果您有一个名为 <code>MyPackage</code> 的包，则文件 <code>src/MyPackage.jl</code> 可以如下所示：</p><pre><code class="language-julia hljs">module MyPackage

using TestItems

export foo

foo(x) = x

@testitem &quot;First tests&quot; begin
    x = foo(&quot;bar&quot;)

    @test length(x)==3
    @test x == &quot;bar&quot;
end

end</code></pre><p>如果您不喜欢这种内联的 <code>@testitem</code> 风格，也可以将 <code>@testitem</code> 块放入测试文件夹中的 Julia 文件中。</p><h2 id="在-VS-Code-中运行测试项"><a class="docs-heading-anchor" href="#在-VS-Code-中运行测试项">在 VS Code 中运行测试项</a><a id="在-VS-Code-中运行测试项-1"></a><a class="docs-heading-anchor-permalink" href="#在-VS-Code-中运行测试项" title="Permalink"></a></h2><p>当您在 VS Code 中打开一个 Julia 包并安装了 <a href="https://www.julia-vscode.org/">Julia 扩展</a> 时，它会不断（每次按键后！）查找您 Julia 文件中的所有 <code>@testitem</code>。如果找到任何 <code>@testitem</code>，它们将出现在用户界面的各个位置。</p><p>您可以在 VS Code 的测试活动栏中找到所有检测到的 <code>@testitem</code>：</p><p><img src="../images/testitems/testactivitybar.png" alt="Test activity bar"/></p><p>测试活动区域提供了运行单个 <code>@testitem</code>、查看结果等的选项。</p><p>S Code 还会在文本编辑器中每个检测到的 <code>@testitem</code> 旁边放置一个小的运行按钮：</p><p><img src="../images/testitems/testrunbutton.png" alt="Test run button"/></p><p>除了所有这些允许您运行测试的 UI 元素之外，还有用于显示测试结果的 UI。例如，当您运行测试并且其中一些测试失败时，扩展将收集所有这些测试失败信息，并在代码中直接显示特定测试失败的位置：</p><p><img src="../images/testitems/testerrordetail.png" alt="Test error detail"/></p><p>特别是在运行大量测试且测试文件较大时，这使得找到具体失败测试变得更加容易，不再需要在 REPL 中寻找文件和行信息！</p><h2 id="从命令行运行测试"><a class="docs-heading-anchor" href="#从命令行运行测试">从命令行运行测试</a><a id="从命令行运行测试-1"></a><a class="docs-heading-anchor-permalink" href="#从命令行运行测试" title="Permalink"></a></h2><p>您可以使用 <a href="https://github.com/julia-vscode/TestItemRunner.jl">TestItemRunner.jl</a> 包作为传统 <code>Pkg.test</code> 工作流的一部分来运行 <code>@testitem</code>。</p><p>要为使用 <code>@testitem</code> 的包启用与 <code>Pkg.test</code> 的集成，您只需做两件事：</p><ol><li>将 <a href="https://github.com/julia-vscode/TestItemRunner.jl">TestItemRunner.jl</a> 作为测试依赖项添加到您的包中</li><li>在包的 <code>test/runtests.jl</code> 文件中放入以下代码：</li></ol><pre><code class="language-julia hljs">using TestItemRunner

@run_package_tests</code></pre><h2 id="标签"><a class="docs-heading-anchor" href="#标签">标签</a><a id="标签-1"></a><a class="docs-heading-anchor-permalink" href="#标签" title="Permalink"></a></h2><p>现在您可以为 <code>@testitem</code> 添加标签。标签可以在 VS Code UI 和通过 <a href="https://github.com/julia-vscode/TestItemRunner.jl">TestItemRunner.jl</a> 中使用，以过滤您想要运行的测试项。</p><p>添加标签的语法如下：</p><pre><code class="language-julia hljs">@testitem &quot;My testitem&quot; tags=[:skipci, :important] begin
    x = foo(&quot;bar&quot;)

    @test length(x)==3
    @test x == &quot;bar&quot;
end</code></pre><p>然后，您可以使用这些相同的标签在 VS Code UI 中过滤测试列表：</p><p><img src="../images/testitems/testitemtagsvscode.png" alt="Test item tags"/></p><p>您还可以在 <code>test/runtests.jl</code> 中使用标签，以过滤将通过传统 <code>Pkg.test</code> 入口点运行的测试列表：</p><pre><code class="nohighlight hljs">using TestItemRunner

@run_package_tests filter=ti-&gt;!(:skipci in ti.tags)</code></pre><p>下面的 [[#TestItemRunner.jl 中的过滤支持]] 部分对 <code>@run_package_tests</code> 宏的新过滤关键字进行了更完整的描述。</p><h2 id="在-VS-Code-中并行执行测试"><a class="docs-heading-anchor" href="#在-VS-Code-中并行执行测试">在 VS Code 中并行执行测试</a><a id="在-VS-Code-中并行执行测试-1"></a><a class="docs-heading-anchor-permalink" href="#在-VS-Code-中并行执行测试" title="Permalink"></a></h2><p>VS Code 扩展有一个设置，控制您想要使用多少 Julia 进程进行并行测试执行：</p><p><img src="../images/testitems/vscodenumtestprocesses.png" alt="Test num test processes"/></p><p>默认值为 <code>1</code>，因此您需要更改此值以使用并行测试执行功能。值为 <code>0</code> 将使用与您的处理器数量相同的测试进程。</p><p>一旦您配置了多个测试进程，单个 <code>@testitem</code> 将并行运行。</p><p>这里有一个权衡：更多的测试进程意味着需要更多内存，并且可能还会有额外的开销来启动所有进程并准备好实际运行 <code>@testitem</code>。</p><h2 id="管理测试进程"><a class="docs-heading-anchor" href="#管理测试进程">管理测试进程</a><a id="管理测试进程-1"></a><a class="docs-heading-anchor-permalink" href="#管理测试进程" title="Permalink"></a></h2><p>通过 VS Code 中的新测试 UI 启动的测试进程不会自动终止，即它们会保持在内存中并占用其他资源。当然，这样做有很多好处，即 <code>@testitem</code> 可以在测试进程启动并运行后非常快速地执行，但在某些情况下，人们可能仍希望简单地终止所有当前正在运行的测试进程。</p><p>为了实现这一点，所有测试进程会在 Julia 工作区中显示，旁边还有任何可能正在运行的 REPL 或 Notebook 进程。您可以通过点击 <code>Stop Test Process</code> 按钮来终止 Julia 测试进程。在这个截图中，有四个测试进程正在运行：</p><h2 id="TestItemRunner.jl-中的过滤支持"><a class="docs-heading-anchor" href="#TestItemRunner.jl-中的过滤支持">TestItemRunner.jl 中的过滤支持</a><a id="TestItemRunner.jl-中的过滤支持-1"></a><a class="docs-heading-anchor-permalink" href="#TestItemRunner.jl-中的过滤支持" title="Permalink"></a></h2><p>您可以将通用过滤函数传递给 <code>@run_package_tests</code> 宏，以选择要执行的 <code>@testitem</code>。上面的部分使用标签来选择要运行的测试，但您还可以根据 <code>@testitem</code> 定义的文件名或 <code>@testitem</code> 的名称进行过滤。</p><p>工作原理是，您可以将过滤函数传递给 <code>@run_package_tests</code> 宏。该过滤函数会针对项目中检测到的每个 <code>@testitem</code> 被调用一次，函数必须返回 <code>true</code>（如果该测试项应运行）或 <code>false</code>（如果不应运行）。<code>@run_package_tests</code> 将传递一个包含三个字段的命名元组给您的过滤函数，这些字段包含有关特定测试项的元信息，分别是字段 <code>filename</code>（定义 <code>@testitem</code> 的文件完整路径）、<code>name</code>（您定义的 <code>@testitem</code> 名称）和 <code>tags</code>（一个 <code>Symbol</code> 的向量）。通过这些信息，您可以编写任意复杂的过滤条件。例如，这里我过滤掉任何具有 <code>:skipci</code> 标签的 <code>@testitem</code>，并且我只运行在特定文件中定义的测试：</p><pre><code class="language-julia hljs">@run_package_tests filter=ti-&gt;( !(:skipci in ti.tags) &amp;&amp; endswith(ti.filename, &quot;test_foo.jl&quot;) )</code></pre><h2 id="默认导入选项"><a class="docs-heading-anchor" href="#默认导入选项">默认导入选项</a><a id="默认导入选项-1"></a><a class="docs-heading-anchor-permalink" href="#默认导入选项" title="Permalink"></a></h2><p>当您编写 <code>@testitem</code> 时，默认情况下，正在测试的软件包和 <code>Test</code> 包通过一个隐式的 <code>using</code> 语句导入。在某些情况下，这可能不是您希望的，因此可以通过 <code>default_imports</code> 选项在每个 <code>@testitem</code> 级别上控制此行为，该选项接受一个 <code>Bool</code> 值。要禁用这些默认导入，您可以这样写：</p><pre><code class="language-julia hljs">@testitem &quot;Another test for foo&quot; default_imports=false begin
    using MyPackage, Test

    x = foo(&quot;bar&quot;)

    @test x != &quot;bar&quot;
end</code></pre><p>注意，我们现在需要手动在 <code>@testitem</code> 中添加行 <code>using MyPackage, Test</code>，以便访问 <code>foo</code> 函数和 <code>@test</code> 宏。</p><h2 id="在-@testitem-之间共享代码"><a class="docs-heading-anchor" href="#在-@testitem-之间共享代码">在 <code>@testitem</code> 之间共享代码</a><a id="在-@testitem-之间共享代码-1"></a><a class="docs-heading-anchor-permalink" href="#在-@testitem-之间共享代码" title="Permalink"></a></h2><p>默认情况下，<code>@testitem</code> 之间不共享任何代码，且彼此之间没有依赖关系。这些特性使得独立运行 <code>@testitem</code> 成为可能，但有时需要在多个 <code>@testitem</code> 之间共享公共代码。测试项框架提供了两个宏来实现这一目的：<code>@testsnippet</code> 和 <code>@testmodule</code>。这两个宏可以出现在包中的任何 <code>.jl</code> 文件中。</p><h3 id="测试片段"><a class="docs-heading-anchor" href="#测试片段">测试片段</a><a id="测试片段-1"></a><a class="docs-heading-anchor-permalink" href="#测试片段" title="Permalink"></a></h3><p><code>@testsnippet</code> 是一个代码块，单个 <code>@testitem</code> 可以在其自己的代码运行之前执行该代码块。如果某个 <code>@testitem</code> 依赖于特定的 <code>@testsnippet</code>，那么该片段将在每次运行 <code>@testitem</code> 时执行。</p><p><code>@testsnippet</code> 的定义可能如下所示：</p><pre><code class="language-julia hljs">@testsnippet MySnippet begin
    foo = &quot;Hello world&quot;
end</code></pre><p><code>@testitem</code> 可以通过使用 <code>setup</code> 关键字来利用这个片段，如下所示：</p><pre><code class="language-julia hljs">@testitem &quot;My test item&quot; setup=[MySnippet] begin
    @test foo == &quot;Hello world&quot;
end</code></pre><h3 id="测试模块"><a class="docs-heading-anchor" href="#测试模块">测试模块</a><a id="测试模块-1"></a><a class="docs-heading-anchor-permalink" href="#测试模块" title="Permalink"></a></h3><p><code>@testmodule</code> 定义了一个可以从 <code>@testitem</code> 访问的 Julia 模块。这样的模块在每个 Julia 测试进程中只会运行 <em>一次</em>。例如，如果两个 <code>@testitem</code> 依赖于同一个 <code>@testmodule</code>，它将只被运行一次，然后整个模块将对两个 <code>@testitem</code> 可用。</p><p><code>@testmodule</code> 的定义可能如下所示：</p><pre><code class="language-julia hljs">@testmodule MyModule begin
    foo = &quot;Hello world&quot;
end</code></pre><p><code>@testitem</code> 可以再次使用 <code>setup</code> 关键字来利用这个模块。与 <code>@testsnippet</code> 不同的是，<code>@testmodule</code> 的内容在一个常规的 Julia <code>module</code> 中运行，因此要访问其中的内容，需要在测试模块定义的名称前加上模块名。利用刚刚定义的 <code>@testmodule</code> 的 <code>@testitem</code> 可能如下所示：</p><pre><code class="language-julia hljs">@testitem &quot;My test item&quot; setup=[MyModule] begin
    @test MyModule.foo == &quot;Hello world&quot;
end</code></pre><p>注意我们在这里用表达式 <code>MyModule.foo</code> 访问 <code>foo</code>。</p><blockquote><p>[!note] 笔者发现，即使 <code>@testmodule</code> 使用 <code>export</code> 导出 <code>foo</code> 函数，<code>@testitem</code> 仍然不能识别 <code>foo</code>，且需要附加模块名。</p></blockquote><h2 id="@testitem-的调试"><a class="docs-heading-anchor" href="#@testitem-的调试"><code>@testitem</code> 的调试</a><a id="@testitem-的调试-1"></a><a class="docs-heading-anchor-permalink" href="#@testitem-的调试" title="Permalink"></a></h2><p>可以通过 <code>Debug Test</code> 命令在调试器中运行 <code>@testitem</code>。这个命令可以在 VS Code UI 的多个地方访问。可以在测试主视图中找到：   <img src="../images/testitems/testitemdebug1.png" alt="Testitem debugging 1"/></p><p>你也可以右击文本编辑器中的运行测试图标，选择调试选项：</p><p><img src="../images/testitems/testitemdebug2.png" alt="Testitem debugging 2"/></p><p>当在调试器中运行测试项时，可以在被测试的代码或 <code>@testitem</code> 本身设置断点，然后利用 Julia VS Code 调试器的所有常规功能。</p><h2 id="代码覆盖率"><a class="docs-heading-anchor" href="#代码覆盖率">代码覆盖率</a><a id="代码覆盖率-1"></a><a class="docs-heading-anchor-permalink" href="#代码覆盖率" title="Permalink"></a></h2><p>在 Julia 1.11 及更高版本中，可以在代码覆盖模式下运行测试项，并直接在 VS Code 中显示代码覆盖结果。</p><p>要以代码覆盖模式运行测试项，可以使用 <code>Run Tests with Coverage</code> 命令启动。该命令在主测试视图：</p><p><img src="../images/testitems/testitemcoverage1.png" alt="Testitem coverage 1"/></p><p>和文本编辑器的右键菜单中都可用：</p><p><img src="../images/testitems/testitemcoverage2.png" alt="Testitem coverage 2"/></p><p>覆盖率结果会以多种方式在 VS Code UI 中显示。例如，总结视图显示每个文件的覆盖情况：</p><p><img src="../images/testitems/testitemcoverageresultsummary.png" alt="Testitem coverage 2"/></p><p>可以在文本编辑器中看到详细的行覆盖信息：</p><p><img src="../images/testitems/testitemcoverageresultdetail.png" alt="Testitem coverage 2"/></p><p>覆盖率结果还会在 VS Code UI 的常规资源管理器部分内联显示。</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="remote.html">« 远程</a><a class="docs-footer-nextpage" href="../devdocs/devdocs.html">概况 »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Friday 25 October 2024 22:03">Friday 25 October 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
